"""
Stores a documented object and the module it is found in.
"""
immutable ObjectPair
    mod :: Module
    obj :: Any
end

(==)(a::ObjectPair, b::ObjectPair) = a.mod == b.mod && a.obj == b.obj


"""
Cache data that is independant of output format.

This function will be called internally by the ``save`` methods prior to
generating static content. Compiled data is cached for later use so that
compilation only has to take place once.
"""
:compile!

function compile!{T}(node::Node{T})
    # Don't compile more than once.
    get(node.cache, :cached, false) && return node
    node.cache[:cached] = true
    # Do things applicable to every node type here.

    ## Nothing yet. ##

    # Dispatch to specialised method.
    compile!(T, node)
    # And finally compile each child node with the same two stage approach.
    for (n, child) in enumerate(node.children)
        compile!(child)
        isa(child, Node) && Elements.assign_id!(child, n)
    end
    node
end

function compile!(::Type{Document}, node::Node)
    Elements.assign_id!(node, 1)
    node
end

function compile!(::Type{Section}, node::Node)
    ## Nothing yet. ##
    node
end

function compile!(::Type{Page}, node::Node)
    compiled  = Dict{UTF8String, Any}()
    formatter = Format{loadformatter(node)}()
    for child in node.children
        isa(child, AbstractString) && (compiled[child] = readtext(formatter, node, child))
    end
    node.cache[:compiled] = compiled
    node
end

"""
Compile each string into an AST generated by the node's ``:format`` formatter.
Group, filter and sort each module.
"""
function compile!(::Type{Docs}, node::Node)
    compiled  = Any[]
    formatter = Format{loadformatter(node)}()
    groupf, filterf, sortf = loadfuncs(node)
    for child in node.children
        if isa(child, AbstractString)
            push!(compiled, readtext(formatter, node, child))
        else # Modules.
            push!(compiled, collatemodule(node, child, groupf, filterf, sortf))
        end
    end
    # Save the output for later rendering.
    node.cache[:compiled] = compiled
    node
end

# Skip anything that isn't a node.
compile!(others...) = nothing


"""
Group, filter, and sort the module contents.
"""
function collatemodule(node::Node, mod::Module, groupf, filterf, sortf)

    groups = Dict{Any, Vector{ObjectPair}}()
    output = Vector{ObjectPair}[]

    # Group and filter objects.
    for object in Cache.objects(mod)
        pair = ObjectPair(mod, object)
        if applyf(filterf, pair)
            key = applyf(groupf, pair)
            haskey(groups, key) || (groups[key] = ObjectPair[])
            push!(groups[key], pair)
        end
    end
    # Sort each group.
    for (k, v) in groups
        sort!(v, lt = sortf)
        push!(output, v)
    end
    # Sort groups by their first object.
    sort!(output, lt = sortf, by = objects -> first(objects))
    output
end


"""
Load user-provided sorting and filtering functions, or use defaults.
"""
function loadfuncs(node::Node{Docs})
    x = Elements.findconfig(node, :group,  Functor)
    y = Elements.findconfig(node, :filter, Functor)
    z = Elements.findconfig(node, :sorter, Functor)

    groupf  =            isnull(x) ? GroupBy.Default()  : get(x)
    filterf =            isnull(y) ? FilterBy.Default() : get(y)
    sortf   = makesorter(isnull(z) ? SortBy.Default()   : get(z))

    groupf, filterf, sortf
end

# We don't have ``call`` overloading in 0.3 so ``lt = functor`` won't work.
if VERSION < v"0.4-dev"
    makesorter(functor) = (a, b) -> applyf(functor, a, b)
else
    makesorter(functor) = functor
end


"""
Load user-provided formatter or use Markdown by default.
"""
function loadformatter(node::Node)
    x = Elements.findconfig(node, :format, DataType)
    isnull(x) ? MarkdownFormatter : get(x)
end
